#!/usr/bin/env python3

from pathlib import PurePath
from sys import stdin

EMPTY    = "    "
NOCHILD  = "│   "
CHILD    = "├── "
ENDCHILD = "└── "

class Path:
    def __init__(self, path: str, target: str = None):
        self.path = PurePath(path)
        self.target = target

    @property
    def parts(self) -> list[str]:
        parts = list(self.path.parts)
        if self.target:
            parts[-1] += f" -> {self.target}"
        return parts


    def __str__(self):
        if self.target is not None:
            return f"{self.path} -> {self.target}"
        return f"{self.path}"

    def __repr__(self):
        return f"Path({self})"

def parse(raw: str) -> list[Path]:
    out = []
    for ln in sorted(raw.strip().splitlines(keepends=False)):
        if "->" in ln:
            link, _, target = ln.split(" ")
            out.append(Path(link, target=target))
        else:
            out.append(Path(ln.strip()))
    return out

def add_item(d: dict, itm: list):
    dir, *rest = itm
    if dir not in d:
        d[dir] = {}
    if rest:
        add_item(d[dir], rest)

def gen_tree(files: list[Path]) -> dict:
    tree = {}
    for f in files:
        add_item(tree, f.parts)
    return tree

def print_tree(tree: dict, pfx: str = "", top: bool = False):
    if not tree:
        return
    sep = CHILD
    dir_sep = NOCHILD
    entries = list(tree)
    for fn in entries:
        if fn is entries[-1]:
            sep = ENDCHILD
            dir_sep = EMPTY if not top else ""
        if isinstance(tree[fn], dict):
            if top:
                print(fn)
            else:
                print(pfx + sep + fn)
            print_tree(tree[fn], pfx + dir_sep)
        else:
            print(pfx + sep + fn)

if __name__ == "__main__":
    raw = parse(stdin.read())
    tree = gen_tree(raw)
    print_tree(tree, top=True)

